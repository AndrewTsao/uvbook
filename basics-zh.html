

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>libuv的基本概念 Basics of libuv &mdash; An Introduction to libuv</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="An Introduction to libuv" href="index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33699076-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>An Introduction to libuv</span></a></h1>
        <h2 class="heading"><span>libuv的基本概念 Basics of libuv</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="libuv-basics-of-libuv">
<h1>libuv的基本概念 Basics of libuv<a class="headerlink" href="#libuv-basics-of-libuv" title="Permalink to this headline">¶</a></h1>
<p>libuv enforces an <strong>asynchronous</strong>, <strong>event-driven</strong> style of programming.  Its
core job is to provide an event loop and callback based notifications of I/O
and other activities.  libuv offers core utilities like timers, non-blocking
networking support, asynchronous file system access, child processes and more.</p>
<p>libuv强调一种 <strong>异步</strong> ， <strong>事件驱动</strong> 的编程风格。它的内核提供了一个事件循环，以及基于IO和其它活动的通知回调机制。
libuv还提供了其它一些核心设施，比如，计时器、无阻塞的网络支持、异步的文件系统访问，子进程等等。</p>
<div class="section" id="event-loops">
<h2>事件循环 Event loops<a class="headerlink" href="#event-loops" title="Permalink to this headline">¶</a></h2>
<p>In event-driven programming, an application express interest in certain events
and respond to them when they occur. The responsibility of gathering events
from the operating system or monitoring other sources of events is handled by
libuv, and the user can register callbacks to be invoked when an event occurs.
The event-loop usually keeps running <em>forever</em>. In pseudocode:
在基于事件的编程中，应用程序将对某些事件的发生表示关注，并在事件发生时做出响应。
libuv负责从操作系统或者其它被监视的事件源收集事件，而用户则负责注册待事件发生时的
回调处理函数。事件循环通常是持续运行的（死循环）。用伪码表示如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">still</span> <span class="n">events</span> <span class="n">to</span> <span class="n">process</span><span class="p">:</span>      <span class="c"># 只要仍有事件需要处理就：</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">get</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">event</span>                    <span class="c"># 获取下一个事件</span>
    <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">callback</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">e</span><span class="p">:</span> <span class="c"># 有与这个事件相关的回调函数？</span>
        <span class="n">call</span> <span class="n">the</span> <span class="n">callback</span>                     <span class="c"># 调用这些回调函数</span>
</pre></div>
</div>
<p>Some examples of events are:</p>
<p>比如以下这些事件：</p>
<ul class="simple">
<li>File is ready for writing　文件写就绪事件</li>
<li>A socket has data ready to be read　网络套接字上有数据到达，读就绪事件</li>
<li>A timer has timed out　计时器超时事件</li>
</ul>
<p>This event loop is encapsulated by <tt class="docutils literal"><span class="pre">uv_run()</span></tt> &#8211; the end-all function when using
libuv.</p>
<p>这个事件循环被封装在 <tt class="docutils literal"><span class="pre">uv_run()</span></tt> ——使用libuv时最后调用的函数。</p>
<p>The most common activity of systems programs is to deal with input and output,
rather than a lot of number-crunching. The problem with using conventional
input/output functions (<tt class="docutils literal"><span class="pre">read</span></tt>, <tt class="docutils literal"><span class="pre">fprintf</span></tt>, etc.) is that they are
<strong>blocking</strong>. The actual write to a hard disk or reading from a network, takes
a disproportionately long time compared to the speed of the processor. The
functions don&#8217;t return until the task is done, so that your program is doing
nothing. For programs which require high performance this is a major roadblock
as other activities and other I/O operations are kept waiting.</p>
<p>在进行系统编程时，最常见的活动就是处理输入输出，而不是做数值相关的计算。而使用
常规的输入输出函数( <tt class="docutils literal"><span class="pre">read</span></tt>, <tt class="docutils literal"><span class="pre">fprintf</span></tt> 等)的问题在于它们都是 <strong>阻塞</strong> 的。在往
硬盘写数据或者从网络中读取数据过程所花费的时间，较之于处理器的速度是很不匹配的。
而这些输入输出函数在未完成实际的写入或者读出任务之前是不会返回的，这将导致你
的程序此时什么都不能做。对于追逐高性能的程序，它阻塞了其它活动的进行，
并迫使其它IO操作被动等待。</p>
<p>One of the standard solutions is to use threads. Each blocking I/O operation is
started in a separate thread (or in a thread pool). When the blocking function
gets invoked in the thread, the processor can schedule another thread to run,
which actually needs the CPU.</p>
<p>一种针对这种问题的标准解决方案是使用线程。每一个阻塞的IO操作在单独的线程中启动
(或者丢入线程池中处理). 当线程调用了具有阻塞性质的函数，如上面的 <tt class="docutils literal"><span class="pre">read</span></tt> 和 <tt class="docutils literal"><span class="pre">fprintf</span></tt>,
处理器可以调入其它需要使用CPU的线程来运行。</p>
<p>The approach followed by libuv uses another style, which is the <strong>asynchronous,
non-blocking</strong> style. Most modern operating systems provide event notification
subsystems. For example, a normal <tt class="docutils literal"><span class="pre">read</span></tt> call on a socket would block until
the sender actually sent something. Instead, the application can request the
operating system to watch the socket and put an event notification in the
queue. The application can inspect the events at its convenience (perhaps doing
some number crunching before to use the processor to the maximum) and grab the
data. It is <strong>asynchronous</strong> because the application expressed interest at one
point, then used the data at another point (in time and space). It is
<strong>non-blocking</strong> because the application process was free to do other tasks.
This fits in well with libuv&#8217;s event-loop approach, since the operating system
events can be treated as just another libuv event. The non-blocking ensures
that other events can continue to be handled as fast they come in <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>libuv采用另一种风格——异步、非阻塞的风格来解决这个问题。大多数现代操作系统提供了
事件通知子系统。举个例子，当应用程序在Socket上执行一个普通的 <tt class="docutils literal"><span class="pre">read</span></tt> 调用时将被阻塞，
直到另一端的发送者发送一些数据过来。另一种替代方式是，应用程序可以请求操作系统去监视socket，
并将事件通知放入到队列当中。而应用程序则在方便的时候（也许当前CPU正忙于数值计算）去检查队列
里的事件并提取数据。这是异步的，是因为应用在某一个时刻表达对数据感兴趣，而在另外一个时刻使
用这些数据。这是非阻塞的，因为应用可以自由的处理是其它任务。这很好的适应了libuv的事件循环方法，
因为操作系统事件正可以作为一个libuv事件来对待。这种非阻塞方式确保其它更快的事件得以尽快的被处理掉.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>How the I/O is run in the background is not of our concern, but due to the
way our computer hardware works, with the thread as the basic unit of the
processor, libuv and OSes will usually run background/worker threads and/or
polling to perform tasks in a non-blocking manner.</p>
<p class="last">我们并不在意I/O在后台是如何进行的。但由于我们的计算机硬件工作方式——处理器线程为基本单元，
libuv和操作系统往往都会以后台线程、工作者线程或者轮询的等非阻塞的方式来执行它们。</p>
</div>
</div>
<div class="section" id="hello-world">
<h2>你好，世界 Hello World<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h2>
<p>With the basics out of the way, lets write our first libuv program. It does
nothing, except start a loop which will exit immediately.</p>
<p>了解了这些基本概念以后，我们来编写第一个libuv程序。它在开启一个事件循环之后就立即退出了，并没做什么事情。</p>
<p class="rubric">helloworld/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;uv.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Now quitting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This program quits immediately because it has no events to process. A libuv
event loop has to be told to watch out for events using the various API
functions.</p>
<p>这个程序立即退出是因为它没有任何事件需要处理。我们可以使用不同的API来通知libuv事件循环监视不同的事件。</p>
<div class="section" id="default-loop">
<h3>默认的事件循环 Default loop<a class="headerlink" href="#default-loop" title="Permalink to this headline">¶</a></h3>
<p>A default loop is provided by libuv and can be accessed using
<tt class="docutils literal"><span class="pre">uv_default_loop()</span></tt>. You should use this loop if you only want a single
loop.</p>
<p>libuv提供了一个默认的事件循环，可以使用 <tt class="docutils literal"><span class="pre">uv_default_loop()</span></tt> 来访问。如果你们只想要一个事件循环，你就应该使用这个。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>node.js uses the default loop as its main loop. If you are writing bindings
you should be aware of this.</p>
<p class="last">node.js使用默认的事件循环作为它的主循环。如果你正在为它编写接口绑定函数的话，你应该是知道这个的。</p>
</div>
</div>
</div>
<div class="section" id="watchers">
<h2>Watchers<a class="headerlink" href="#watchers" title="Permalink to this headline">¶</a></h2>
<p>Watchers are how users of libuv express interest in particular events. Watchers
are opaque structs named as <tt class="docutils literal"><span class="pre">uv_TYPE_t</span></tt> where type signifies what the watcher
is used for. A full list of watchers supported by libuv is:</p>
<p>libuv用户通过Watchers来表示关注特定事件的发生。Watchers是一些以 <tt class="docutils literal"><span class="pre">uv_TYPE_t</span></tt> 的方式来命名的不透明的数据结构，
其中的type表示Watcher所针对的事件类型。以下列表完整列举了libuv所支持的Watcher.</p>
<p class="rubric">libuv watchers</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_loop_s</span> <span class="n">uv_loop_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_ares_task_s</span> <span class="n">uv_ares_task_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_err_s</span> <span class="n">uv_err_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_handle_s</span> <span class="n">uv_handle_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_stream_s</span> <span class="n">uv_stream_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_tcp_s</span> <span class="n">uv_tcp_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_udp_s</span> <span class="n">uv_udp_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_pipe_s</span> <span class="n">uv_pipe_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_tty_s</span> <span class="n">uv_tty_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_poll_s</span> <span class="n">uv_poll_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_timer_s</span> <span class="n">uv_timer_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_prepare_s</span> <span class="n">uv_prepare_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_check_s</span> <span class="n">uv_check_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_idle_s</span> <span class="n">uv_idle_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_async_s</span> <span class="n">uv_async_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_getaddrinfo_s</span> <span class="n">uv_getaddrinfo_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_process_s</span> <span class="n">uv_process_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_counters_s</span> <span class="n">uv_counters_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_cpu_info_s</span> <span class="n">uv_cpu_info_t</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>All watcher structs are subclasses of <tt class="docutils literal"><span class="pre">uv_handle_t</span></tt> and often referred to
as <strong>handles</strong> in libuv and in this text.</p>
<p class="last">所有Watcher结构都是 <tt class="docutils literal"><span class="pre">uv_handle_t</span></tt> 的子类，在libuv和本文中经常称为 <strong>handles</strong> （句柄）。</p>
</div>
<p>Watchers are setup by a corresponding:</p>
<p>各种类型的Watchers以相应初始化函数进行初始配置：</p>
<blockquote>
<div>uv_TYPE_init(uv_TYPE_t*)</div></blockquote>
<p>function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Some watcher initialization functions require the loop as a first argument.</p>
<p class="last">还有一些类型的Watcher的初始化函数需要以loop作为第一个参数。</p>
</div>
<p>A watcher is set to actually listen for events by invoking:</p>
<p>让一个Watcher开始监听事件，可以通过调用：</p>
<blockquote>
<div>uv_TYPE_start(uv_TYPE_t*, callback)</div></blockquote>
<p>and stopped by calling the corresponding:</p>
<p>相应的让wather停止监听事件通过调用：</p>
<blockquote>
<div>uv_TYPE_stop(uv_TYPE_t*)</div></blockquote>
<p>Callbacks are functions which are called by libuv whenever an event the watcher
is interested in has taken place. Application specific logic will usually be
implemented in the callback. For example, an IO watcher&#8217;s callback will receive
the data read from a file, a timer callback will be triggered on timeout and so
on.</p>
<p>Callbacks（回调函数）是指当某些被Watcher所关注的事件在任何时候发生时将由libuv所调用的函数。
应用程序特定的处理逻辑通常是以回调的方式来实现的。比如，一个IO Watcher的回调函数将接收从文件读取的数据，
而一个计时器回调函数将在计时器超时时被触发，诸如此类。</p>
<div class="section" id="idling">
<h3>Idling　空闲状态<a class="headerlink" href="#idling" title="Permalink to this headline">¶</a></h3>
<p>Here is an example of using a watcher. An idle watcher&#8217;s callback is repeatedly
called. There are some deeper semantics, discussed in <a class="reference internal" href="utilities.html"><em>Utilities</em></a>, but
we&#8217;ll ignore them for now. Let&#8217;s just use an idle watcher to look at the
watcher life cycle and see how <tt class="docutils literal"><span class="pre">uv_run()</span></tt> will now block because a watcher is
present. The idle watcher is stopped when the count is reached and <tt class="docutils literal"><span class="pre">uv_run()</span></tt>
exits since no event watchers are active.
下面给出一个使用Watcher的例子。一个空闲状态Watcher的回调函数将被反复调用。这里涉及了一些
在 <a class="reference internal" href="utilities.html"><em>Utilities</em></a> 中讨论的较深入的语义，但现在我们忽略它们。让我们仅仅使用Idle watcher来
审视一下watcher的生命周期，并且看看 <tt class="docutils literal"><span class="pre">uv_run()</span></tt> 是如何在watcher存在时被阻塞的。Idle watcher
将在计数器计数满时停止，然后 <tt class="docutils literal"><span class="pre">uv_run()</span></tt> 因没有活动的watcher存在而退出。</p>
<p class="rubric">idle-basic/main.c</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;uv.h&gt;</span>

<span class="kt">int64_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="hll"><span class="kt">void</span> <span class="nf">wait_for_a_while</span><span class="p">(</span><span class="n">uv_idle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span>    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="mf">10e6</span><span class="p">)</span>
<span class="hll">        <span class="n">uv_idle_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="hll">    <span class="n">uv_idle_t</span> <span class="n">idler</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="n">uv_idle_init</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">idler</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_idle_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idler</span><span class="p">,</span> <span class="n">wait_for_a_while</span><span class="p">);</span>
</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Idling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">uv_run</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">());</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>void *data pattern</p>
<p>note about not necessarily creating type structs on the stack</p>
<p>注意并没有必要将这些类型的数据结构创建在栈上，此处只是为了演示。</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Depending on the capacity of the hardware of course.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, Nikhil Marathe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>