

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>网络功能 Networking &mdash; An Introduction to libuv</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="An Introduction to libuv" href="index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33699076-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>An Introduction to libuv</span></a></h1>
        <h2 class="heading"><span>网络功能 Networking</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="networking">
<h1>网络功能 Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h1>
<p>Networking in libuv is not much different from directly using the BSD socket
interface, some things are easier, all are non-blocking but the concepts stay
the same. In addition libuv offers utility functions to abstract the annoying,
repetitive and low-level tasks like setting up sockets using the BSD socket
structures, DNS lookup, and tweaking various socket parameters.</p>
<p>libuv的网络部分，较之直接使用BSD套接字接口而言，差异不大，只是某些方面更加
易用，并且所有的操作都是非阻塞的，概念保持不变。另外，libuv提供了相关的
工具函数，抽象了那些烦人的、重复的、低级别的任务，比如使用BSD套接字结构启动
socket，DNS查询，调节不同的socket参数等。</p>
<p>The <tt class="docutils literal"><span class="pre">uv_tcp_t</span></tt> and <tt class="docutils literal"><span class="pre">uv_udp_t</span></tt> structures are used for network I/O.</p>
<p>网络IO中使用了 <tt class="docutils literal"><span class="pre">uv_tcp_t</span></tt> 和 <tt class="docutils literal"><span class="pre">uv_udp_t</span></tt> 数据结构。</p>
<div class="section" id="tcp">
<h2>TCP<a class="headerlink" href="#tcp" title="Permalink to this headline">¶</a></h2>
<p>TCP is a connection oriented, stream protocol and is therefore based on the
libuv streams infrastructure.</p>
<p>TCP是面向连接的、流传输协议，实现上理所当然是基于libuv流基础设施的。</p>
<div class="section" id="server">
<h3>服务器 Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h3>
<p>Server sockets proceed by:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">uv_tcp_init</span></tt> the TCP watcher.</li>
<li><tt class="docutils literal"><span class="pre">uv_tcp_bind</span></tt> it.</li>
<li>Call <tt class="docutils literal"><span class="pre">uv_listen</span></tt> on the watcher to have a callback invoked whenever a new
connection is established by a client.</li>
<li>Use <tt class="docutils literal"><span class="pre">uv_accept</span></tt> to accept the connection.</li>
<li>Use <a class="reference internal" href="filesystem-zh.html#buffers-and-streams"><em>stream operations</em></a> to communicate with the
client.</li>
</ol>
<p>服务端Socket使用过程如下：
1. <tt class="docutils literal"><span class="pre">uv_tcp_init</span></tt> 初始化一个TCP Watcher.
2. <tt class="docutils literal"><span class="pre">uv_tcp_bind</span></tt> 绑定监听地址和端口。
3. 调用 <tt class="docutils literal"><span class="pre">uv_listen</span></tt> 在Watcher上绑定一个回调函数，当客户建立一个连接时，该回</p>
<blockquote>
<div>调函数将被调用。</div></blockquote>
<ol class="arabic simple" start="4">
<li>使用 <tt class="docutils literal"><span class="pre">uv_accept</span></tt> 来接受一个连接。</li>
<li>使用流操作(<a class="reference internal" href="filesystem-zh.html#buffers-and-streams"><em>stream operations</em></a>) 的方式与客户端进
行通讯。</li>
</ol>
<p>Here is a simple echo server</p>
<p class="rubric">tcp-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_tcp_t</span> <span class="n">server</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span>
<span class="hll">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">bind_addr</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">7000</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">bind_addr</span><span class="p">);</span>
</span><span class="hll">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Listen error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>下面是一个简单的Echo服务器实例。</p>
<p class="rubric">tcp-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_tcp_t</span> <span class="n">server</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span>
<span class="hll">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">bind_addr</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">7000</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">bind_addr</span><span class="p">);</span>
</span><span class="hll">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Listen error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>You can see the utility function <tt class="docutils literal"><span class="pre">uv_ip4_addr</span></tt> being used to convert from
a human readable IP address, port pair to the sockaddr_in structure required by
the BSD socket APIs. The reverse can be obtained using <tt class="docutils literal"><span class="pre">uv_ip4_name</span></tt>.</p>
<p>实例代码中的利用辅助函数 <tt class="docutils literal"><span class="pre">uv_ip4_addr</span></tt> 将人类易读的IP地址，端口对转换为BSD套接
字API要求的sockaddr_in结构体。反过来可以使用 <tt class="docutils literal"><span class="pre">uv_ip4_name</span></tt> 从结构体中获取IP地址
和端口号。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In case it wasn&#8217;t obvious there are <tt class="docutils literal"><span class="pre">uv_ip6_*</span></tt> analogues for the ip4
functions.</p>
<p class="last">还有一系列的 <tt class="docutils literal"><span class="pre">uv_i6_*</span></tt> 函数族，它们提供了与ip4函数相同的功能。此例未展示。</p>
</div>
<p>Most of the setup functions are normal functions since its all CPU-bound.
<tt class="docutils literal"><span class="pre">uv_listen</span></tt> is where we return to libuv&#8217;s callback style. The second
arguments is the backlog queue &#8211; the maximum length of queued connections.</p>
<p>大多数的设置函数是普通函数因为它们都是受限于CPU的。 <tt class="docutils literal"><span class="pre">uv_listen</span></tt> 调用之后我们又
开始使用libuv回调风格了。它的第二个参数是指积压的接收队列——表示最大的列队连接数。</p>
<p>When a connection is initiated by clients, the callback is required to set up
a watcher for the client socket and associate the watcher using <tt class="docutils literal"><span class="pre">uv_accept</span></tt>.
In this case we also establish interest in reading from this stream.</p>
<p>当客户端发起了一个连接时，需要回调一个函数来为客户端Socket设置一个watcher，这可以
通过 <tt class="docutils literal"><span class="pre">uv_accept</span></tt> 来完成。既然这样，我们也要可以在这个流上面设置读操作。</p>
<p class="rubric">tcp-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">echo_read</span><span class="p">);</span>
</span>    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The remaining set of functions is very similar to the streams example and can
be found in the code. Just remember to call <tt class="docutils literal"><span class="pre">uv_close</span></tt> when the socket isn&#8217;t
required. This can be done even in the <tt class="docutils literal"><span class="pre">uv_listen</span></tt> callback if you are not
interested in accepting the connection.</p>
<p>实例代码中的其它函数的使用和流操作实例中的非常相似。不过请记住，当Sket不再需要时，
要调用 <tt class="docutils literal"><span class="pre">uv_close</span></tt> . 这个过程甚至可以在 <tt class="docutils literal"><span class="pre">uv_listen</span></tt> 的回调函数中完成，如果你
对所接受的连接不感兴趣的话。</p>
</div>
<div class="section" id="client">
<h3>客户端 Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h3>
<p>Where you do bind/listen/accept, on the client side its simply a matter of
calling <tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt>. The same <tt class="docutils literal"><span class="pre">uv_connect_cb</span></tt> style callback of
<tt class="docutils literal"><span class="pre">uv_listen</span></tt> is used by <tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt>. Try:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uv_tcp_t</span> <span class="n">socket</span><span class="p">;</span>
<span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">socket</span><span class="p">);</span>

<span class="n">uv_connect_t</span> <span class="n">connect</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>

<span class="n">uv_tcp_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">socket</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">on_connect</span></tt> will be called after the connection is established.</p>
<p>相对于服务端的 bind/listen/accept操作，在客户端你只需要简单的调用 <tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt> ，
<tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt> 使用与 <tt class="docutils literal"><span class="pre">uv_listen</span></tt> 相同的 <tt class="docutils literal"><span class="pre">uv_connect_cb</span></tt> 的风格的回调函数。
小试一下:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uv_tcp_t</span> <span class="n">socket</span><span class="p">;</span>
<span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">socket</span><span class="p">);</span>

<span class="n">uv_connect_t</span> <span class="n">connect</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>

<span class="n">uv_tcp_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">socket</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</pre></div>
</div>
<p>此例中 <tt class="docutils literal"><span class="pre">on_connect</span></tt> 将在连接建立之后被调用。</p>
</div>
</div>
<div class="section" id="udp">
<h2>UDP<a class="headerlink" href="#udp" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol</a> offers connectionless, unreliable network
communication. Hence, unlike TCP, it doesn&#8217;t offer a stream abstraction since
each packet is independent. libuv provides non-blocking UDP support via the
<cite>uv_udp_t</cite> (for receiving) and <cite>uv_udp_send_t</cite> (for sending) structures and
related functions. That said, the actual API for reading/writing is very
similar to normal stream reads. To look at how UDP can be used, the example
shows the first stage of obtaining an IP address from a <a class="reference external" href="http://tools.ietf.org/html/rfc2131">DHCP</a> server &#8211; DHCP
Discover.</p>
<p>用户数据报文协议（UDP, <a class="reference external" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol</a> ）提供无连接的、不可靠的网络通讯机制。因此，不像TCP，它不提供
流的抽象，因为每个数据包都是彼此独立的。 libuv通过 <cite>uv_udp_t</cite> （接收）和 <cite>uv_udp_send_t</cite> （发送）
两种数据结构及相关的函数，提供了非阻塞的UDP支持。据说，实际用于读写操作的API和普通的流读取
操作非常的相似。为展示如何使用UDP，接下来的实例演示了从 <a class="reference external" href="http://tools.ietf.org/html/rfc2131">DHCP</a> 服务器获取IP地址
的第一阶段——DHCP发现。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You will have to run <cite>udp-dhcp</cite> as <strong>root</strong> since it uses well known port
numbers below 1024.</p>
<p class="last">你需要以 <strong>root</strong> 身份来运行 <cite>udp-dhcp`</cite> ，因为它使用了小于1024以下的知名端口。</p>
</div>
<p class="rubric">udp-dhcp/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">send_socket</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">recv_socket</span><span class="p">;</span>

    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">);</span>
<span class="hll">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">recv_addr</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">68</span><span class="p">);</span>
</span>    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="n">recv_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_udp_recv_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
</span><span class="hll">
</span>    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">);</span>
    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_udp_set_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="hll">
</span>    <span class="n">uv_udp_send_t</span> <span class="n">send_req</span><span class="p">;</span>
    <span class="n">uv_buf_t</span> <span class="n">discover_msg</span> <span class="o">=</span> <span class="n">make_discover_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_req</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">send_addr</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;255.255.255.255&quot;</span><span class="p">,</span> <span class="mi">67</span><span class="p">);</span>
    <span class="n">uv_udp_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">discover_msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">send_addr</span><span class="p">,</span> <span class="n">on_send</span><span class="p">);</span>
<span class="hll">
</span>    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The IP address <tt class="docutils literal"><span class="pre">0.0.0.0</span></tt> is used to bind to all interfaces. The IP
address <tt class="docutils literal"><span class="pre">255.255.255.255</span></tt> is a broadcast address meaning that packets
will be sent to all interfaces on the subnet.  port <tt class="docutils literal"><span class="pre">0</span></tt> means that the OS
randomly assigns a port.</p>
<p class="last">IP地址 <tt class="docutils literal"><span class="pre">0.0.0.0</span></tt> 表示绑定所有的网卡。IP地址 <tt class="docutils literal"><span class="pre">255.255.255.255</span></tt> 是广播地址，
表示将数据发送到当前子网中的所有设备上。端口 <tt class="docutils literal"><span class="pre">0</span></tt> 意味着操作系统随机分配一个端口。</p>
</div>
<p>First we setup the receiving socket to bind on all interfaces on port 68 (DHCP
client) and start a read watcher on it. Then we setup a similar send socket and
use <tt class="docutils literal"><span class="pre">uv_udp_send</span></tt> to send a <em>broadcast message</em> on port 67 (DHCP server).</p>
<p>首先我们设置一个接口Socket并绑定所有的网卡的68端口(DHCP)端口并开始监视上面的读操作。
然后，我们设置一个相似的发送Socket，并使用 <tt class="docutils literal"><span class="pre">uv_udp_send</span></tt> 向67端口(DHCP服务器)发送
一个 <em>广播消息</em> 。</p>
<p>It is <strong>necessary</strong> to set the broadcast flag, otherwise you will get an
<tt class="docutils literal"><span class="pre">EACCES</span></tt> error <a class="footnote-reference" href="#id9" id="id1">[1]</a>. The exact message being sent is irrelevant to this book
and you can study the code if you are interested. As usual the read and write
callbacks will receive a status code of -1 if something went wrong.</p>
<p>这里 <strong>必需</strong> 设置广播标志，否则你将得到一个 <tt class="docutils literal"><span class="pre">EACCES</span></tt> 的错误 <a class="footnote-reference" href="#id10" id="id2">[2]</a>. 至于消息是
如何发送的过程并非此书所关心的，如果你感兴趣的话，可以研习代码。和一般的读写回
调一样，如果过程中有错误的话，你将收到一个被标记为-1的状态码。</p>
<p>Since UDP sockets are not connected to a particular peer, the read callback
receives an extra parameter about the sender of the packet. The <tt class="docutils literal"><span class="pre">flags</span></tt>
parameter may be <tt class="docutils literal"><span class="pre">UV_UDP_PARTIAL</span></tt> if the buffer provided by your allocator
was not large enough to hold the data. <em>In this case the OS will discard the
data that could not fit</em> (That&#8217;s UDP for you!).</p>
<p>因为UDP套接字并不连接到某一个特定端，读回调函数会接受到一个关于数据包发送者
信息的参数。 如果你的分配器未能提供足够空间的缓冲区容纳接收到的数据的话，
<tt class="docutils literal"><span class="pre">flags</span></tt> 参数可能是 <tt class="docutils literal"><span class="pre">UV_UDP_PARTIAL</span></tt> 。这时候，操作系统将丢弃那些容不下的数据。
(这正是UDP所决定的!)。</p>
<p class="rubric">udp-dhcp/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="n">uv_udp_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Read error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">base</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">sender</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Recv from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sender</span><span class="p">);</span>

    <span class="c1">// ... DHCP specific code</span>

    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">base</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_udp_recv_stop</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="udp-udp-options">
<h3>UDP选项 UDP Options<a class="headerlink" href="#udp-udp-options" title="Permalink to this headline">¶</a></h3>
<p>The TTL of packets sent on the socket can be changed using <tt class="docutils literal"><span class="pre">uv_udp_set_ttl</span></tt>.</p>
<p>如果必要，可以使用 <tt class="docutils literal"><span class="pre">uv_udp_set_ttl</span></tt> 来修改发送到某个 socket 上的数据包的TTL.</p>
<div class="section" id="ipv6-ipv6-stack-only">
<h4>只使用IPv6协议 IPv6 stack only<a class="headerlink" href="#ipv6-ipv6-stack-only" title="Permalink to this headline">¶</a></h4>
<p>IPv6 sockets can be used for both IPv4 and IPv6 communication. If you want to
restrict the socket to IPv6 only, pass the <tt class="docutils literal"><span class="pre">UV_UDP_IPV6ONLY</span></tt> flag to
<tt class="docutils literal"><span class="pre">uv_udp_bind6</span></tt> <a class="footnote-reference" href="#id11" id="id3">[3]</a>.</p>
<p>IPv6 套接字能够同时用于IPv4和IPv6的通讯，如果你希望仅限于IPv6的话，你可以在调用
<tt class="docutils literal"><span class="pre">uv_udp_bind6</span></tt> 时传入 <tt class="docutils literal"><span class="pre">UV_UDP_IPV6ONLY</span></tt> 标志。</p>
</div>
<div class="section" id="multicast">
<h4>多播 Multicast<a class="headerlink" href="#multicast" title="Permalink to this headline">¶</a></h4>
<p>A socket can (un)subscribe to a multicast group using:</p>
<p>一个套接字可以如下的方式订阅或者退订一个多播组：
.. literalinclude:: ../libuv/include/uv.h</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">lines:</th><td class="field-body">738</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>where <tt class="docutils literal"><span class="pre">membership</span></tt> is <tt class="docutils literal"><span class="pre">UV_JOIN_GROUP</span></tt> or <tt class="docutils literal"><span class="pre">UV_LEAVE_GROUP</span></tt>.</p>
<p>参数 <tt class="docutils literal"><span class="pre">membership</span></tt> 可以是 <tt class="docutils literal"><span class="pre">UV_JOIN_GROPU</span></tt> 和 <tt class="docutils literal"><span class="pre">UV_LEAVE_GROUP</span></tt>.</p>
<p>Local loopback of multicast packets is enabled by default <a class="footnote-reference" href="#id12" id="id4">[4]</a>, use
<tt class="docutils literal"><span class="pre">uv_udp_set_multicast_loop</span> <span class="pre">to</span> <span class="pre">switch</span> <span class="pre">it</span> <span class="pre">off</span></tt>.</p>
<p>多播包的本地回环是被默认设置的 <a href="#id13"><span class="problematic" id="id14"><span id="id5"></span>[#]_</span></a>, 可以使用 <tt class="docutils literal"><span class="pre">uv_udp_set_multicast_loop</span></tt> 来关闭它。</p>
<p>The packet time-to-live for multicast packets can be changed using
<tt class="docutils literal"><span class="pre">uv_udp_set_multicast_ttl</span></tt>.</p>
<p>多播包的TTL可以利用 <tt class="docutils literal"><span class="pre">uv_udp_set_multicast_ttl</span></tt> 修改。</p>
</div>
</div>
</div>
<div class="section" id="dns-querying-dns">
<h2>DNS 查询 Querying DNS<a class="headerlink" href="#dns-querying-dns" title="Permalink to this headline">¶</a></h2>
<p>libuv provides asynchronous DNS resolution. For this it provides its own
<tt class="docutils literal"><span class="pre">getaddrinfo</span></tt> replacement <a href="#id13"><span class="problematic" id="id15"><span id="id6"></span>[#]_</span></a>. In the callback you can
perform normal socket operations on the retrieved addresses. Let&#8217;s connect to
Freenode to see an example of DNS resolution.</p>
<p>libuv提供了异步的域名解析功能。为些它提供了它自己的 <tt class="docutils literal"><span class="pre">getaddrinfo</span></tt> 替代函数 <a href="#id13"><span class="problematic" id="id16"><span id="id7"></span>[#]_</span></a>.
在回调函数中你可以在查询到的地址上执行Socket操作。下例中通过连接Freenode来展示一下DNS解析过程。</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_protocol</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">uv_getaddrinfo_t</span> <span class="n">resolver</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;irc.freenode.net is... &quot;</span><span class="p">);</span>
<span class="hll">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_getaddrinfo</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resolver</span><span class="p">,</span> <span class="n">on_resolved</span><span class="p">,</span> <span class="s">&quot;irc.freenode.net&quot;</span><span class="p">,</span> <span class="s">&quot;6667&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">);</span>
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo call error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If <tt class="docutils literal"><span class="pre">uv_getaddrinfo</span></tt> returns non-zero, something went wrong in the setup and
your callback won&#8217;t be invoked at all. All arguments can be freed immediately
after <tt class="docutils literal"><span class="pre">uv_getaddrinfo</span></tt> returns. The <cite>hostname</cite>, <cite>servname</cite> and <cite>hints</cite>
structures are documented in <a class="reference external" href="getaddrinfo">the getaddrinfo man page</a>.</p>
<p>如果 <tt class="docutils literal"><span class="pre">uv_getaddrinfo</span></tt> 返回非零，表示你的设置哪里出了问题，此时不要指望你的回
调函数会被调用。所有的参数可以在 <tt class="docutils literal"><span class="pre">uv_getaddrinfo</span></tt> 返回之后立即释放掉。 <cite>hostname</cite>,
<cite>servname</cite> 和 <cite>hints</cite> 结构体可以参考 <a class="reference external" href="getaddrinfo">the getaddrinfo man page</a>.</p>
<p>In the resolver callback, you can pick any IP from the linked list of <tt class="docutils literal"><span class="pre">struct</span>
<span class="pre">addrinfo(s)</span></tt>. This also demonstrates <tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt>. It is necessary to
call <tt class="docutils literal"><span class="pre">uv_freeaddrinfo</span></tt> in the callback.</p>
<p>在解析器回调函数中，你可以使用 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">addrinfo(s)</span></tt> 链表中的任何一个IP地址。
下例也演示了 <tt class="docutils literal"><span class="pre">uv_tcp_connect</span></tt> 的使用方法。在回调函数中，你必须调用 <tt class="docutils literal"><span class="pre">uv_freeaddrinfo</span></tt>
释放相关资源。</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_resolved</span><span class="p">(</span><span class="n">uv_getaddrinfo_t</span> <span class="o">*</span><span class="n">resolver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo callback error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">addr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="hll">    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">connect_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_connect_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_connect_t</span><span class="p">));</span>
    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

    <span class="n">connect_req</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">socket</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_tcp_connect</span><span class="p">(</span><span class="n">connect_req</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</span>
    <span class="n">uv_freeaddrinfo</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="network-interfaces">
<h2>Network interfaces<a class="headerlink" href="#network-interfaces" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast">http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>on Windows only supported on Windows Vista and later.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1">http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>libuv use the system <tt class="docutils literal"><span class="pre">getaddrinfo</span></tt> in the libuv threadpool. libuv
v0.8.0 and earlier also included <a class="reference external" href="http://c-ares.haxx.se">c-ares</a> as an alternative, but this has been
removed in v0.9.0.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, Nikhil Marathe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>